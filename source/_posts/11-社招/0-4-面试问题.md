---
title: 0-3 个人介绍
date: 2023-01-01 16:03:37
categories:
    - 社招
tags:
    - 社招
---

# 一、数据库
## 1 介绍PostgreSQL的架构
- 进程架构：
    - 与应用交互：
        - 1个postmaster进程：负责监听客户端连接，为不同的连接创建新进程，控制共享资源
        - 多个postgres进程：postmaster与客户端建立TCP连接后，负责接收与处理客户端的请求
            - 共享区域：Page / Wal / Clog
    - 与磁盘交互
        - bgwriter进程：postgres进程从磁盘读取到数据到内存，在内存中操作数据，产生脏数据。bgwriter进程负责将脏数据写到磁盘
        - walwriter进程：负责不断地将postgres等进程产生的wal日志写到磁盘
        - checkpointer进程：负责将内存中所有的脏数据写到磁盘，并生产1个checkpoint点，故障恢复时，可从checkpoint点开始恢复
    - 辅助管理：
        - autovacuum进程：负责清理过期的数据
        - archive进程：负责归档checkpoint之前，较旧的WAL日志
        - statcollertor进程：负责收集统计信息
    - 主备管理：
        - walsender进程：不断读取和发送WAL日志到备机
        - walreceiver进程：不断接收和存储来自主机的WAL日志
- 上述进程中，postgres线程，是处理SQL语句的关键线程，内部又分为：
    - 计算模块（5个模块）：
        - 语法解析
        - 语义分析
        - 查询重写
        - 计划生产
        - 计划执行
    - 存储模块（不太好划分，以典型的插入数据来看，从执行流程上来看）：
        - am接口：heapam， indexam层
        - 事务模块：为数据设置事务信息
        - fsm模块
        - vm模块：查找具有空闲空间的Page
        - share buffer模块：缓存了最近常用的Page
        - smgr层：统一的存储接口
            - vfd层
        - Page管理
        - wal模块
        - wal buffer模块

## 1.1 事务的4个特性
- ACID的基本即使：
    - **原子性**：一个事务，可能执行多个写操作；多个写操作，是一个整体，要么都成功，要么都失败
    - **隔离性**（DML间）：多个事务场景，一个事务，执行写操作时，根据事务隔离级别，控制写操作对其他并发事务的影响
    - **持久化**：计算机有内存和外存，一个事务，在事务提交前，写操作应该记录在外存。在断电等特殊情况下，已提交事务的写操作，不应该丢失
    - **一致性**：事务执行前后，整个数据库的状态，符合预期。主键、外键、检查、触发器。ALTER ADD COLUMN
- PostgreSQL实现ACID的机制：
    - 原子性：
        - 事务id：标识属于同一个事务的所有写操作
        - 提交日志：记录事务id对应的事务的状态，是已提交，还是已回滚
    - 隔离性：通过MVCC机制实现
        - 数据多版本共存：数据库同时记录多个事务写操作产生的数据
        - 事务快照：记录所有事务的状态
        - 可见性判断：基于事务快照，可判断不同版本数据的可见性
        - 辅助
            - VACUUM机制：回收旧版本数据
            - 事务提示位：提高可见性判断的效率
    - 持久化
        - WAL日志：WAL日志记录写操作、写入的数据、写入的位置、事务状态变化。一个事务生成的WAL日志落盘，表示事务成功
    - 一致性
        - 无
- PostgreSQL实现ACID的基本流程：
    - analyze前：获取事务的快照：无论显式还是隐式事务，语法解析后，识别到INSERT语法，在语义分析前，会获取事务id
        - 获取方法：遍历所有活跃进程的进程控制块，从进程控制块中获取事务id及其状态
    - INSERT
        1. heapam：最开始组装tuple时，申请事务id，同时在提交日志中，记录事务id处于未提交状态
        2. 初始化1个tuple，记录数据，同时，在tuple的头部，记录事务信息，首先，记录插入tuple的事务id，即本事务id，然后，删除tuple的事务id，设置为0。还有，记录command id
        3. 选择1个Page，将tuple存至page中
        4. 生成一条wal record，记录tuple，记录tuple被存到哪个page，以及page中的位置
        5. 如果显式制定BEGIN，则在执行COMMIT / ROLLBACK时；如果未显式指定BEGIN，则在计划执行完成时。首先，确保Wal Record已落盘，然后，在提交日志中，更新事务id对应的事务状态，同时为其生成1条wal record，确保wal record已落盘
        6. 最后，通知客户端，事务执行成功
    - DELETE
        1. heamp：第一步，申请事务id，提交日志记录事务状态
        2. 从page中，读取tuple，从tuple的头部中，分别获取插入tuple的事务id、删除tuple的事务id，根据进程控制块中的事务信息，以及事务快照，判断tuple是否可见
            - 写写冲突
        3. 如果tuple可见，则将tuple中，删除的事务id，更新为自己的事务id
        4. 生成1条wal record，记录tuple，tuple的位置，tuple头部事务id的变化
        5. 最后，在事务执行结束时，确保记录数据变化，以及记录事务状态变化的wal record已落盘
        6. 最后，通知客户端，事务执行成功
    - UPDATE
        1. 1个delete和1个insert
    - SELECT
        1. 不用申请事务id
        2. 只检查可见性
        3. 不生成wal record
    - 其他
        - 持久化 - 故障恢复
        - 回收旧元组 - VACUMM


## 2 事务的4个特性
1. 原子性 Atomicity
    - 概念：1个事务中，执行的多个SQL语句，产生的写操作，要么都成功，要么都失败
    - 实现：
        - 1. 申请事务Id：每个存在写操作的事务，都会申请唯一的事务Id
        - 2. 记录事务状态：数据库维护一份提交日志，提交日志中记录所有事务的的状态
        - 3. 数据携带事务Id：在存储模块，表中一行数据，存在一个Tuple里。Tuple的头部，会记录事务Id。比如：执行INSERT语法，生产新Tuple时，Tuple会记录插入的事务Id。执行DELETE语法时，Tuple会记录删除的Id
        - 4. 可见性判断：也就是合法性判断。根据Tuple头部
        - 一、识别：同一事务的所有写操作
            - 获取事务id：写操作的事务，会申请事务id，每个事务id都是唯一的
            - 携带事务id：SQL语句中的1行数据，存储在1个Tuple中，Tuple中除了记录数据，还记录事务id
        - 二、维护：事务的状态
            - 初始提交日志：每个事务id，都有对应的事务日志，它记录事务的状态
            - 更新提交日志：每个事务提交时，都会在事务提交日志中，将事务状态更新未已提交；事务回滚时，在事务日志中，将事务状态更新为已回滚
        - 三、检查：数据对应事务的状态，成功还是失败
            - 读到Tuple时，从Tuple中获取事务id，根据事务id，检查提交日志中的事务状态
2. 隔离性 Isolation
    - 概念：1个事务，有未提交、已提交、已回滚等状态。多个事务，并发执行时，不同事务，不应该看到其他事务未提交的数据，也就是多个事务间的隔离性
    - 实现：MVCC多版本并发控制机制，实现隔离性。有几个关键点：
        - 一、数据携带版本信息：每个Tuple携带事务id，事务id是唯一的。另外，事务id还有一个递增的特性，也就是，先开始的事务，id小，后开始的事务，id大。根据Tuple中事务id大小，可判断操作Tuple的先后顺序。
        - 二、多版本数据共存：
            - 插入数据时，每个Tuple记录事务id，即记录数据版本
            - 删除数据时，每个Tuple记录删除的事务id，即记录删除版本
            - 在同一时刻内，多个事务插入、删除数据，都会同时存在
        - 三、事务状态共享：在提交日志、进程控制块中，记录了事务状态，这些状态对所有事务可见
        - 四、事务快照：1个事务执行时，会根据设置的隔离级别，获取事务快照。事务快照中记录了所有事务的状态
        - 五、事务可见性判断：获取Tuple时，从Tuple中获取事务id，根据事务快照，判断Tuple可见性，实现不同事务对Tuple操作的的隔离性
        - 辅助
            - 多版本数据共存：Vacuum机制清理旧版本数据
            - 事务可见性判断：提示位，避免重复检查Clog
3. 持久性 Durability
    - 概念：1个事务，执行SQL语句，产生写数据的操作后。在提交事务时，需确保写操作都已被写入磁盘。事务提交后，即使发生断电等异常后，也不会出现事务提交了，但数据没更新的情况。
    - 实现：通过WAL日志，记录所有关键的写操作以及数据
    - 背景：执行SQL语句时，最终目标是，确保数据被写到对应的文件中。比如，INSERT一个表，确保数据被写到表文件中。但是，一个事务会写很多文件，要解决多个文件操作的持久化，开销很高
        - 一、内存操作数据：在执行写操作时，先在内存更新数据
        - 二、生成WAL日志：WAL日志记录写操作、以及数据本身。记录事务状态的变化
        - 三、落盘WAL日志：提交事务时，需确保事务产生的WAL日志已被存至磁盘
        - 四、故障恢复：在发生断电等异常后，如果一个事务提交了，但没达到最终目标，也就是数据没被写到对应的文件中。这时，数据库通过WAL日志，可还原写操作、以及数据本身。
4. 一致性 Consistency
    - 概念：事务前后，数据库的状态都是合法的。保证了原子性、隔离性、持久性，也就达到了一致性的目标
 -
## 3 介绍Checkpoint
- 背景：
    - 写数据最终目标：执行写数据的操作时，最终目标是将数据写到对应的文件中
    - 事务持久化：为了提高性能，同时解决事务持久化问题，引入了WAL日志。事务提交时，只确保WAL日志落盘。
    - 异常场景：如果发生异常时，WAL日志落盘了，但是WAL日志中记录的数据，没被写到对应的文件中
    - 故障恢复：下次重启进程时，需要检查是否出现了WAL日志落盘，但是WAL日志中记录的数据，未被写到对应的文件中的情况。
    - Checkpoint机制：帮助识别哪些WAL日志中记录的数据，是否被写到对应的文件中。主要场景是，故障恢复的时候，从checkpoint点之后开始回放WAL日志
- Checkpoint机制：
    - 独立进程：在一定时间间隔，或者触发条件下，不停地将内存中的脏页，写到磁盘
    - 脏页落盘：ShareBuffer中、Commit日志等脏数据落盘
    - 记录WAL日志：生成一个WAL日志，记录checkpoint点
    - 更新PgControl文件：记录checkpoint的位置
    - 启动进程时，startup阶段：会在wal日志中，从后往前，查找checkpoint点，从checkpoint点开始回放wal日志