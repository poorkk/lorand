---
title: 0-3 个人介绍
date: 2023-01-01 16:03:37
categories:
    - 社招
tags:
    - 社招
---

# 一、数据库
## 1 介绍数库的架构
- 进程架构：
    - 与应用交互：
        - 1个postmaster进程：负责监听客户端连接，为不同的连接创建新进程，控制共享资源
        - 多个postgres进程：postmaster与客户端建立TCP连接后，负责接收与处理客户端的请求
            - 共享区域：Page / Wal / Clog
    - 与磁盘交互
        - bgwriter进程：postgres进程从磁盘读取到数据到内存，在内存中操作数据，产生脏数据。bgwriter进程负责将脏数据写到磁盘
        - walwriter进程：负责不断地将postgres等进程产生的wal日志写到磁盘
        - checkpointer进程：负责将内存中所有的脏数据写到磁盘，并生产1个checkpoint点，故障恢复时，可从checkpoint点开始恢复
    - 辅助管理：
        - autovacuum进程：负责清理过期的数据
        - archive进程：负责归档checkpoint之前，较旧的WAL日志
        - statcollertor进程：负责收集统计信息
    - 主备管理：
        - walsender进程：不断读取和发送WAL日志到备机
        - walreceiver进程：不断接收和存储来自主机的WAL日志
- 上述进程中，postgres线程，是处理SQL语句的关键线程，内部又分为：
    - 计算模块（5个模块）：
        - 语法解析
        - 语义分析
        - 查询重写
        - 计划生产
        - 计划执行
    - 存储模块（不太好划分，以典型的插入数据来看，从执行流程上来看）：
        - am接口：heapam， indexam层
        - 事务模块：为数据设置事务信息
        - fsm模块
        - vm模块：查找具有空闲空间的Page
        - share buffer模块：缓存了最近常用的Page
        - smgr层：统一的存储接口
            - vfd层
        - Page管理
        - wal模块
        - wal buffer模块

## 2 事务的4个特性
1. 原子性 Atomicity
    - 概念：1个事务中，执行的多个SQL语句，产生的写操作，要么都成功，要么都失败
    - 实现：
        - 1. 申请事务Id：每个存在写操作的事务，都会申请唯一的事务Id
        - 2. 记录事务状态：数据库维护一份提交日志，提交日志中记录所有事务的的状态
        - 3. 数据携带事务Id：在存储模块，表中一行数据，存在一个Tuple里。Tuple的头部，会记录事务Id。比如：执行INSERT语法，生产新Tuple时，Tuple会记录插入的事务Id。执行DELETE语法时，Tuple会记录删除的Id
        - 4. 可见性判断：也就是合法性判断。根据Tuple头部
        - 一、识别：同一事务的所有写操作
            - 获取事务id：写操作的事务，会申请事务id，每个事务id都是唯一的
            - 携带事务id：SQL语句中的1行数据，存储在1个Tuple中，Tuple中除了记录数据，还记录事务id
        - 二、维护：事务的状态
            - 初始提交日志：每个事务id，都有对应的事务日志，它记录事务的状态
            - 更新提交日志：每个事务提交时，都会在事务提交日志中，将事务状态更新未已提交；事务回滚时，在事务日志中，将事务状态更新为已回滚
        - 三、检查：数据对应事务的状态，成功还是失败
            - 读到Tuple时，从Tuple中获取事务id，根据事务id，检查提交日志中的事务状态
2. 隔离性 Isolation
    - 概念：1个事务，有未提交、已提交、已回滚等状态。多个事务，并发执行时，不同事务，不应该看到其他事务未提交的数据，也就是多个事务间的隔离性
    - 实现：MVCC多版本并发控制机制，实现隔离性。有几个关键点：
        - 一、数据携带版本信息：每个Tuple携带事务id，事务id是唯一的。另外，事务id还有一个递增的特性，也就是，先开始的事务，id小，后开始的事务，id大。根据Tuple中事务id大小，可判断操作Tuple的先后顺序。
        - 二、多版本数据共存：
            - 插入数据时，每个Tuple记录事务id，即记录数据版本
            - 删除数据时，每个Tuple记录删除的事务id，即记录删除版本
            - 在同一时刻内，多个事务插入、删除数据，都会同时存在
        - 三、事务状态共享：在提交日志、进程控制块中，记录了事务状态，这些状态对所有事务可见
        - 四、事务快照：1个事务执行时，会根据设置的隔离级别，获取事务快照。事务快照中记录了所有事务的状态
        - 五、事务可见性判断：获取Tuple时，从Tuple中获取事务id，根据事务快照，判断Tuple可见性，实现不同事务对Tuple操作的的隔离性
        - 辅助
            - 多版本数据共存：Vacuum机制清理旧版本数据
            - 事务可见性判断：提示位，避免重复检查Clog
3. 持久性 Durability
    - 概念：1个事务，执行SQL语句，产生写数据的操作后。在提交事务时，需确保写操作都已被写入磁盘。事务提交后，即使发生断电等异常后，也不会出现事务提交了，但数据没更新的情况。
    - 实现：通过WAL日志，记录所有关键的写操作以及数据
    - 背景：执行SQL语句时，最终目标是，确保数据被写到对应的文件中。比如，INSERT一个表，确保数据被写到表文件中。但是，一个事务会写很多文件，要解决多个文件操作的持久化，开销很高
        - 一、内存操作数据：在执行写操作时，先在内存更新数据
        - 二、生成WAL日志：WAL日志记录写操作、以及数据本身。记录事务状态的变化
        - 三、落盘WAL日志：提交事务时，需确保事务产生的WAL日志已被存至磁盘
        - 四、故障恢复：在发生断电等异常后，如果一个事务提交了，但没达到最终目标，也就是数据没被写到对应的文件中。这时，数据库通过WAL日志，可还原写操作、以及数据本身。
4. 一致性 Consistency
    - 概念：事务前后，数据库的状态都是合法的。保证了原子性、隔离性、持久性，也就达到了一致性的目标
 -
## 3 介绍Checkpoint
- 背景：
    - 写数据最终目标：执行写数据的操作时，最终目标是将数据写到对应的文件中
    - 事务持久化：为了提高性能，同时解决事务持久化问题，引入了WAL日志。事务提交时，只确保WAL日志落盘。
    - 异常场景：如果发生异常时，WAL日志落盘了，但是WAL日志中记录的数据，没被写到对应的文件中
    - 故障恢复：下次重启进程时，需要检查是否出现了WAL日志落盘，但是WAL日志中记录的数据，未被写到对应的文件中的情况。
    - Checkpoint机制：帮助识别哪些WAL日志中记录的数据，是否被写到对应的文件中。主要场景是，故障恢复的时候，从checkpoint点之后开始回放WAL日志
- Checkpoint机制：
    - 独立进程：在一定时间间隔，或者触发条件下，不停地将内存中的脏页，写到磁盘
    - 脏页落盘：ShareBuffer中、Commit日志等脏数据落盘
    - 记录WAL日志：生成一个WAL日志，记录checkpoint点
    - 更新PgControl文件：记录checkpoint的位置
    - 启动进程时，startup阶段：会在wal日志中，从后往前，查找checkpoint点，从checkpoint点开始回放wal日志