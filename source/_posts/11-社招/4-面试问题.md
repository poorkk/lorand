---
title: z 社招 面试问题
date: 2023-01-01 16:03:37
categories:
    - 社招
tags:
    - 社招
---

# 一、数据库
## 1 介绍PostgreSQL的架构
- 进程架构：
    - 与应用交互：
        - 1个postmaster进程：负责监听客户端连接，为不同的连接创建新进程，控制共享资源
        - 多个postgres进程：postmaster与客户端建立TCP连接后，负责接收与处理客户端的请求
            - 共享区域：Page / Wal / Clog
    - 与磁盘交互
        - bgwriter进程：postgres进程从磁盘读取到数据到内存，在内存中操作数据，产生脏数据。bgwriter进程负责将脏数据写到磁盘
        - walwriter进程：负责不断地将postgres等进程产生的wal日志写到磁盘
        - checkpointer进程：负责将内存中所有的脏数据写到磁盘，并生产1个checkpoint点，故障恢复时，可从checkpoint点开始恢复
    - 辅助管理：
        - autovacuum进程：负责清理过期的数据
        - archive进程：负责归档checkpoint之前，较旧的WAL日志
        - statcollertor进程：负责收集统计信息
    - 主备管理：
        - walsender进程：不断读取和发送WAL日志到备机
        - walreceiver进程：不断接收和存储来自主机的WAL日志
- 上述进程中，postgres线程，是处理SQL语句的关键线程，内部又分为：
    - 计算模块（5个模块）：
        - 语法解析
        - 语义分析
        - 查询重写
        - 计划生产
        - 计划执行
    - 存储模块（不太好划分，以典型的插入数据来看，从执行流程上来看）：
        - am接口：heapam， indexam层
        - 事务模块：为数据设置事务信息
        - fsm模块
        - vm模块：查找具有空闲空间的Page
        - share buffer模块：缓存了最近常用的Page
        - smgr层：统一的存储接口
            - vfd层
        - Page管理
        - wal模块
        - wal buffer模块

## 1.1 事务的4个特性
- ACID的基本即使：
    - **原子性**：一个事务，可能执行多个写操作；多个写操作，是一个整体，要么都成功，要么都失败
    - **隔离性**（DML间）：多个事务场景，一个事务，执行写操作时，根据事务隔离级别，控制写操作对其他并发事务的影响
    - **持久化**：计算机有内存和外存，一个事务，在事务提交前，写操作应该记录在外存。在断电等特殊情况下，已提交事务的写操作，不应该丢失
    - **一致性**：事务执行前后，整个数据库的状态，符合预期。主键、外键、检查、触发器。ALTER ADD COLUMN
- PostgreSQL实现ACID的机制：
    - 原子性：
        - 事务id：标识属于同一个事务的所有写操作
        - 提交日志：记录事务id对应的事务的状态，是已提交，还是已回滚
    - 隔离性：通过MVCC机制实现
        - 数据多版本共存：数据库同时记录多个事务写操作产生的数据
        - 事务快照：记录所有事务的状态
        - 可见性判断：基于事务快照，可判断不同版本数据的可见性
        - 辅助
            - VACUUM机制：回收旧版本数据
            - 事务提示位：提高可见性判断的效率
    - 持久化
        - WAL日志：WAL日志记录写操作、写入的数据、写入的位置、事务状态变化。一个事务生成的WAL日志落盘，表示事务成功
    - 一致性
        - 无
- PostgreSQL实现ACID的基本流程：
    - analyze前：获取事务的快照：无论显式还是隐式事务，语法解析后，识别到INSERT语法，在语义分析前，会获取事务id
        - 获取方法：遍历所有活跃进程的进程控制块，从进程控制块中获取事务id及其状态
    - INSERT
        1. heapam：最开始组装tuple时，申请事务id，同时在提交日志中，记录事务id处于未提交状态
        2. 初始化1个tuple，记录数据，同时，在tuple的头部，记录事务信息，首先，记录插入tuple的事务id，即本事务id，然后，删除tuple的事务id，设置为0。还有，记录command id
        3. 选择1个Page，将tuple存至page中
        4. 生成一条wal record，记录tuple，记录tuple被存到哪个page，以及page中的位置
        5. 如果显式制定BEGIN，则在执行COMMIT / ROLLBACK时；如果未显式指定BEGIN，则在计划执行完成时。首先，确保Wal Record已落盘，然后，在提交日志中，更新事务id对应的事务状态，同时为其生成1条wal record，确保wal record已落盘
        6. 最后，通知客户端，事务执行成功
    - DELETE
        1. heamp：第一步，申请事务id，提交日志记录事务状态
        2. 从page中，读取tuple，从tuple的头部中，分别获取插入tuple的事务id、删除tuple的事务id，根据进程控制块中的事务信息，以及事务快照，判断tuple是否可见
            - 写写冲突
        3. 如果tuple可见，则将tuple中，删除的事务id，更新为自己的事务id
        4. 生成1条wal record，记录tuple，tuple的位置，tuple头部事务id的变化
        5. 最后，在事务执行结束时，确保记录数据变化，以及记录事务状态变化的wal record已落盘
        6. 最后，通知客户端，事务执行成功
    - UPDATE
        1. 1个delete和1个insert
    - SELECT
        1. 不用申请事务id
        2. 只检查可见性
        3. 不生成wal record
    - 其他
        - 持久化 - 故障恢复
        - 回收旧元组 - VACUMM


## 2 事务的4个特性
1. 原子性 Atomicity
    - 概念：1个事务中，执行的多个SQL语句，产生的写操作，要么都成功，要么都失败
    - 实现：
        - 1. 申请事务Id：每个存在写操作的事务，都会申请唯一的事务Id
        - 2. 记录事务状态：数据库维护一份提交日志，提交日志中记录所有事务的的状态
        - 3. 数据携带事务Id：在存储模块，表中一行数据，存在一个Tuple里。Tuple的头部，会记录事务Id。比如：执行INSERT语法，生产新Tuple时，Tuple会记录插入的事务Id。执行DELETE语法时，Tuple会记录删除的Id
        - 4. 可见性判断：也就是合法性判断。根据Tuple头部
        - 一、识别：同一事务的所有写操作
            - 获取事务id：写操作的事务，会申请事务id，每个事务id都是唯一的
            - 携带事务id：SQL语句中的1行数据，存储在1个Tuple中，Tuple中除了记录数据，还记录事务id
        - 二、维护：事务的状态
            - 初始提交日志：每个事务id，都有对应的事务日志，它记录事务的状态
            - 更新提交日志：每个事务提交时，都会在事务提交日志中，将事务状态更新未已提交；事务回滚时，在事务日志中，将事务状态更新为已回滚
        - 三、检查：数据对应事务的状态，成功还是失败
            - 读到Tuple时，从Tuple中获取事务id，根据事务id，检查提交日志中的事务状态
2. 隔离性 Isolation
    - 概念：1个事务，有未提交、已提交、已回滚等状态。多个事务，并发执行时，不同事务，不应该看到其他事务未提交的数据，也就是多个事务间的隔离性
    - 实现：MVCC多版本并发控制机制，实现隔离性。有几个关键点：
        - 一、数据携带版本信息：每个Tuple携带事务id，事务id是唯一的。另外，事务id还有一个递增的特性，也就是，先开始的事务，id小，后开始的事务，id大。根据Tuple中事务id大小，可判断操作Tuple的先后顺序。
        - 二、多版本数据共存：
            - 插入数据时，每个Tuple记录事务id，即记录数据版本
            - 删除数据时，每个Tuple记录删除的事务id，即记录删除版本
            - 在同一时刻内，多个事务插入、删除数据，都会同时存在
        - 三、事务状态共享：在提交日志、进程控制块中，记录了事务状态，这些状态对所有事务可见
        - 四、事务快照：1个事务执行时，会根据设置的隔离级别，获取事务快照。事务快照中记录了所有事务的状态
        - 五、事务可见性判断：获取Tuple时，从Tuple中获取事务id，根据事务快照，判断Tuple可见性，实现不同事务对Tuple操作的的隔离性
        - 辅助
            - 多版本数据共存：Vacuum机制清理旧版本数据
            - 事务可见性判断：提示位，避免重复检查Clog
3. 持久性 Durability
    - 概念：1个事务，执行SQL语句，产生写数据的操作后。在提交事务时，需确保写操作都已被写入磁盘。事务提交后，即使发生断电等异常后，也不会出现事务提交了，但数据没更新的情况。
    - 实现：通过WAL日志，记录所有关键的写操作以及数据
    - 背景：执行SQL语句时，最终目标是，确保数据被写到对应的文件中。比如，INSERT一个表，确保数据被写到表文件中。但是，一个事务会写很多文件，要解决多个文件操作的持久化，开销很高
        - 一、内存操作数据：在执行写操作时，先在内存更新数据
        - 二、生成WAL日志：WAL日志记录写操作、以及数据本身。记录事务状态的变化
        - 三、落盘WAL日志：提交事务时，需确保事务产生的WAL日志已被存至磁盘
        - 四、故障恢复：在发生断电等异常后，如果一个事务提交了，但没达到最终目标，也就是数据没被写到对应的文件中。这时，数据库通过WAL日志，可还原写操作、以及数据本身。
4. 一致性 Consistency
    - 概念：事务前后，数据库的状态都是合法的。保证了原子性、隔离性、持久性，也就达到了一致性的目标
 -
## 3 介绍Checkpoint
- 背景：
    - 写数据最终目标：执行写数据的操作时，最终目标是将数据写到对应的文件中
    - 事务持久化：为了提高性能，同时解决事务持久化问题，引入了WAL日志。事务提交时，只确保WAL日志落盘。
    - 异常场景：如果发生异常时，WAL日志落盘了，但是WAL日志中记录的数据，没被写到对应的文件中
    - 故障恢复：下次重启进程时，需要检查是否出现了WAL日志落盘，但是WAL日志中记录的数据，未被写到对应的文件中的情况。
    - Checkpoint机制：帮助识别哪些WAL日志中记录的数据，是否被写到对应的文件中。主要场景是，故障恢复的时候，从checkpoint点之后开始回放WAL日志
- Checkpoint机制：
    - 独立进程：在一定时间间隔，或者触发条件下，不停地将内存中的脏页，写到磁盘
    - 脏页落盘：ShareBuffer中、Commit日志等脏数据落盘
    - 记录WAL日志：生成一个WAL日志，记录checkpoint点
    - 更新PgControl文件：记录checkpoint的位置
    - 启动进程时，startup阶段：会在wal日志中，从后往前，查找checkpoint点，从checkpoint点开始回放wal日志

# 1 密态数据库
- 概述：业界最安全的数据库安全方案。解决数据传输、计算、存储安全性。
- 问题：攻击者直接攻击数据库，比如，获取数据库较高权限账户，操作系统高权限账户等
    - 实现原理：
        - 存储数据时：在数据库驱动端，比如JDBC/ODBC中，自动加密SQL语法中的数据
        - 查询数据时：在数据库计算模块，解决密文数据无法计算的问题。在数据库驱动端，解密服务端返回的查询解密密文。
- 从用户的角度：
    1. 使用SQL语法，定义密钥对象
    2. 在创建表阶段，CREATE TABLE时，为某个列设置加密属性
    3. 执行INSERT等语法存储数据时，应用感知不到加密过程。但是，如果对驱动和数据库之间的通信数据抓包，会发现INSERT语法中，某些列的值，被自动替换为加密后的值
    4. 执行SELECT等语法查询数据时，驱动返回的结果，是数据明文
- 从实现的角度：
    1. 新语法：提供语法，支持用户定义密钥模型、加密模型，使用哪个密钥，对哪个列加密
    2. 驱动端：
        - 语法解析：识别SELECT、INSERT、UPDATE等需要处理的语法
        - 语义分析：
            - 在DML语法中，识别每条数据属于哪个列，判断是否需加密列数据，识别列由哪个密钥加密
            - 复杂场景：UNION、嵌套子查询等
        - 加密数据：访问外部的密钥管理服务，获取密钥，实现加密
    3. 服务端：
        - 语义分析：
            - 约束：
                1. 密文列上，仅支持等值查询
                2. 绕过加密的场景，比如SELECT INTO
                3. 密钥不同，不同列不能计算，比如JOIN
        - 计划执行：
            - 算子适配：排序算子、连接算子，密文无法比较大小，关键的比较计算需要发送到可行执行环境
            - 函数计算：各种函数无法直接在密文上计算。比如，最常见的范围查询、模糊查询等，语义分析阶段会统一将他们转换为函数。
            - 可行环境交互问题：数据发送、数据解密、函数结算、结果加密
        - 驱动端
            - 解密服务端返回的密文结果
- 我的工作
    - 驱动端
        - 部分语法解析
        - 部分语义分析
        - 全部数据加密、密钥管理
            - 对接不同密钥服务，对接密码机
    - 服务端
        - 部分算子执行
            - JOIN算子、Index Scan算子、Sort算子
        - 全部的可行执行环境交互
            - 数据封装、通信交互、数据解密、结果加密、结果接受等

# 2 安全传输
- 概述：解决应用和数据库通信的安全性，主要是机密性和完整性
- 问题：
    - 弱点：子啊应用端机器，服务端机器，以及二者中间的网络中
    - 攻击：嗅探，欺骗
    - 威胁：
        - 泄露：密码传输、SQL语句、查询结果
        - 伪造：欺骗后，构造SQL查询，绕过身份认证
- 从用户的角度：
    1. 生成证书：分别为应用端、数据库端，生成2套证书
    2. 配置参数：配置应用端、数据库端参数，开启通信加密时，设置证书路径
    3. 数据交互：应用端连接数据库，执行SQL语句，抓取二者通信链路上的包，发现通信数据都被加密了
- 从实现的角度：
    1. 生成证书：openssl提供自签名证书，各大云服务上也提供证书服务
    2. 配置参数：如果开启功能，如何读取证书
    3. 建立连接：
        - 应用与数据库，建立TCP连接后，调用一系列SSL提供的接口，让每个TCP连接进行TLS协议握手，以生成密钥。- 每次通信时，先用密钥加密数据，再传输数据
        - 数据库没有做太多工作，主要是调用openssl接口。不过，我本身是学安全的，知道里面的技术细节
- 我的工作：
    - 国密适配：生成国密证书、设置国密参数、国密稍微复杂些，有2套证书
    - 易用性改造：证书有效期、吊销列表有效期，如果过期，可以不报错，只提示
        - openssl提供错误处理回到函数，TLS建连失败时，我们在回调函数中，识别特定的异常，然后bypass

# 3 加密函数
# 4 身份认证
- 原理：比较常见的概念，提供账号和密码，才能登录系统，执行其他操作
- 背景：
    - 服务器：因为数据库本身也是一个服务器，监听特定端口，谁都可以建立TCP连接，要区分是非法用户，还是合法用户
    - PG：稍微复杂一点点，支持基于主机的身份认证，不同的IP，采用不同的认证方式
- 从用户的角度
    1. 创建用户：生成账号、设置账号密码
    2. 主机认证：针对不同的IP，设置不同的认证方式
    3. 连接数据库：使用账号、密码，连接数据库。如果账号和密码正确，才能连接，然后执行SQL和其他操作
- 从实现的角度
    1. 创建用户：支持语法，存储密码。密码存在系统表中，不能直接存储密码明文，而是存哈希值
    2. 主机认证：解析配置参数，不同的ip，使用不同的认证方式
    3. 连接数据库：密码不能直接传，有个交互过程，有个标准格式，传输密码的hash值
- 我的工作：
    - 密码的hash值，是密码学中的hash算法，支持国密算法
        - 配置、交互过程等有简单适配

# 5 访问控制
- 背景：
    - 举例：比较成熟的概念。在Linux中，一个用户创建文件，其他用户没有权限访问。
    - 概念：访问控制机制，有3个基本概念，主体，客体，和操作。Linux中，主体是用户，客体是文件，操作是读文件，写文件和执行文件
- 概述：在数据中，访问控制要复杂的多
    - 主体是用户
    - 客体是database, schema, table, row。其他：存储过程、密钥
    - 操作：CREATE DROP / TRUNCATE，INSERT / UPDATE / DELETE等
- 从用户的角度
    1. 创建对象
    2. 赋权：
        - 谁可以操作，怎么操作，什么条件下操作
    3. 鉴权：其他用户，操作对象时，如果没有赋权，会失败
- 从实现的角度
    - 访问控制机制：
        - 自主访问控制：主体创建客体，主体定义客体的可访问列表，客体存储可访问列表
        - 强制访问控制
        - 角色访问控制
        - 规则访问控制
    - 流程
        1. 创建对象：存储权限模型。不同对象，不一样的算法，不一样的存储方法
            - 自主访问控制：表的acl，存在pg_class中
            - 强制访问控制：
            - 角色访问控制：pg_member存储具有同组关系的角色
            - 规则访问控制：
        2. 赋权：不同访问控制机制，不一样的赋权语法
            - 自主访问控制：ALTER .. PRIVALIGE
            - 角色访问控制：ALTER ROLE ADD
            - 规则访问控制：
        3. 鉴权：从系统表中，获取权限模型，判断当前用户，是否符合权限模型
            - 自主访问控制：计划初始化，生成tle
            - 强制访问控制：
            - 角色访问控制：计划初始化
            - 规则访问控制：语义分析，增加AND过滤条件

# 6 安全审计
- 原理：记录日志
- 背景：记录主体、客体、操作
    - 主体：用户
    - 客体：集群、用户、连接、数据对象（database、schema、表、索引、存储过程）
    - 操作：登录集群、建立连接、DDL、DML等
- 从用户角度
    1. 开启审计功能
        - 传统审计：设置是否审计某类客体
        - 统一审计：通过语法，定义是否审计某一个客体（表、角色、列）
    2. 正常访问数据库
    3. 查询审计日志
        - 主体：用户名、用户IP、用户端口
        - 客体：客体名、客体的内容、客体所在节点
        - 操作：操作的时间、操作的类型、操作的结果
- 从实现的角度
    - 传统审计：
        - 关键流程：比如，启动数据库、建立连接、身份认证结束等，记录结果
        - 语义分析：根据分析树的类型，识别操作类型，操作的客体，以及客体的属性
    - 统一审计：
        - 语法定义：支持创建资源标签
        - 语义分析：判断操作类型，识别客体，遍历系统表，判断客体是否需要审计