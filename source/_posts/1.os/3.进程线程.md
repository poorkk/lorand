---
title: 操作系统 3 进程管理
date: 2023-01-01 16:03:37
categories:
    - 操作系统
tags:
    - 操作系统
---

# 1 进程
## 1.1 概述
- 进程
  - 定义：Process/Task/Job 定义：某个数据集合上一次运行活动。资源分配单位。
  - 实现：进程控制块 Process Control Block PCB：进程描述符，进程属性
    - 基本信息：pid, 进程名，userid
    - CPU现场：寄存器，程序计数器，状态字PSW，栈指针，页表指针
    - 控制信息：状态，优先级，代码执行入口，程序磁盘地址，运行统计信息（执行时间，页面调度），进程同步与通信，进程队列指针，进程消息队列指针
    - 资源信息：虚拟地址空间，打开的文件
  - 状态：
    - 分类：
      - 就绪态：CPU不空闲
        - -> 运行：被调度程序选中
      - 运行态：
        - -> 就绪：时间片用完，高优先级抢占
        - -> 等待：系统调用、IO、进程通信、...
      - 等待态：阻塞
        - -> 就绪：等待事件发生
      - 创建态：
      - 终止态：进程结束，统计运行信息，资源回收
      - 挂起态：调节负载）（进程映像交换到磁盘）
    - linux 进程状态：
      ```c
      fork()  ->  就绪态  ->  运行态  +-->  浅度睡眠 --+
                                    |               |
                                    +-->  深度睡眠 --+
                                    |               |--> 就绪态 （wake_up / 信号）
                                    +--> 暂停     --+
                                    |              |
                                    +--> 僵尸     --+
      就绪->运行：schedule()
      运行->就绪：时间片结束
      运行->浅度睡眠：等待资源，interruptible_sleep_on()，schedule()
      运行->深度睡眠：等待资源，sleep_on()，schedule()
      运行->暂停：ptrace调试，schedule()
      ```
  - 进程队列
    进程状态改变：从一个队列出队，进入另一个队列
    等待队列：等待事件不同，有多个等待队列
  - 进程生命周期
    - 创建 fork/exec：分配pid，分配pcb，复制父进程地址空间（linux优化：当子进程要写父进程地址时，才复制地址空间），继承父进程共享资源(打开的文件，工作目录)，设置队列指针
    - 阻塞 wait 等待子进程：自己执行阻塞原语
    - 唤醒
    - 挂起
    - 激活
    - 撤销 exit：关闭文件，回收内存，撤销pcb
  - 进程切换
    - 进程地址空间
      ```c
      --------- 用户地址空间
      栈
      .
      .
      .
      堆
      ---------
      数据段
      ---------
      代码段
      ---------
      ...
      ----------- 操作系统地址空间
      内核栈
      -----------
      内核代码
      ------------
      ```
    - 上下文切换：将cpu硬件状态从一个进程换到另一个进程
      - 直接开销：保护和恢复寄存器、切换地址空间
      - 间接开销：高速缓存失效、缓冲区缓存失效、TLB失效
  - 进程通信
    - 信号
    - 信号量 （锁）
    - 消息队列 （传递数据 + 阻塞）
    - 管道 （传递数据 + 阻塞）
    - 共享内存 （传递数据 + 阻塞）
    - 套接字 （传递数据 + 阻塞）

线程
  - 进程问题
    - 创建进程开销大：数据段、代码段、堆、栈段
    - 进程隔离性强：IPC开销大
    - 进程内部无法支持并行
  - 线程优点
    - 构成：执行所需最小状态：寄存器和栈（每个线程有自己的栈，共享数据、代码、堆）
      - 线程id，线程状态，线程上下文，线程栈和栈指针
    - 开销小：创建和销毁，切换，通信
    - 性能高：多处理器并发执行
  
  - 线程模型（用户线程 与 内核线程）
    - 多对一
    - 一对一：内核线程数量大
    - 多对多
  - 线程调度
    - 调度场景
      ```bash
      [t1]                [CPU1]
      [t2] -> [调度器] ->  
      [t3]                [CPU2]
      ```
    - 调度算法
      - 衡量标准
        - 吞吐量
        - 周转时间：请求 -> 运行
        - 响应时间：请求 -> 第一次回应

        - CPU利用率
        - 等待时间：就绪 -> 运行
      - 算法分类
        - 算法类型
          | 算法 | 实现 | 优点 | 缺点 |
          |-|-|-|-|
          批处理系统 |
          先来先服务 FCFS | - | 公平、简单 | 长任务不友好
          最短作业优先 SJF | - | 最短平均周转 | 长任务不友好
          最短剩余时间优先 SRTN | 
          最高响应比优先 HRRN | 响应时间 = （处理时间 + 等待时间） / 处理时间 
          交互式系统 |
          时间片轮转 RR | - | 公平、响应快 | 进程切换开销高、IO进程不友好 （IO进程进入优先级高、独立就绪队列）
          最高优先级 HPF | 优先级动态或静态 | - | 低优先级饥饿、优先级反转（低优先级进程持有锁，高优先级进程抢占，低优先级无法执行）
          多级反馈队列 MFQ | 多个就绪队列，优先级依次降低，时间片依次增加，时间片轮转调度，高优先级优先调度
          最短进程优先 |
        - 操作系统
          | OS | 策略 |
          |-|-|
          unix | 动态优先
          BSD | 多级反馈
          Linux | 抢占
          Windows | 32优先级抢占（优先级进入就绪队列）
          Solaris | 综合调度
    - 调度问题
      - 优先级反转
        使用临界区资源时：
        - 优先级上限：优先级临时设为最高
        - 优先级继承：临时继承最高优先级
        - 禁止中断：禁止被抢占
  - 线程通信
    - 临界区
      - 要求
        - 互斥访问
        - 有限等待
        - 空闲让进
      - 算法
        - 皮特森算法 (?)
          ```c
          // 进程 0
          while (1) {
            flag[0] = true;
            turn = 1;
            while (flag[1] == true && turn == 1) {
              /* 临界区 */
              flag[0] = false;
            }
          }

          // 进程 1
          while (1) {
            flag[1] = true;
            turn = 0;
            while (flag[0] == true && turn == 0) {
              /* 临界区 */
              flag[1] = false;
            }
          }
          ```
        - 硬件原子
          - 概念
            - 不可被打断的操作集合
            - 其他核心不会看到中间状态
          - 实现
            - intel 锁总线
            - arm LL/SC
    - 线程锁
      - 自旋锁
      - 读写锁
    - 线程死锁
      - 预防
        - 避免互斥访问
        - 不允许持有并等待
        - 不允许资源抢占
        - 打破循环等待（按特定顺序获取资源）
      - 解决
        - 银行家算法
          - 获取资源需管理者同意
          - 管理者预演不会造成死锁
  - 多核缓存
    ```bash
    [  cpu 0 ] [  cpu 1 ]      [  cpu 2 ] [  cpu 3 ]
    [l1 cache] [l1 cache]      [l1 cache] [l1 cache]

    [     l2 cache      ]      [      l2 cache     ]

    [                  l3 cache                    ]

    [                     内存                     ]
    ```
    - 缓存一致性
      - 原则
        - 独占修改
          - cpu核独占缓存行：本地可读可写
          - 其他核读需迁移到共享
          - 其他核写需迁移到失效
        - 共享
          - 多核拷贝缓存行
          - 本地可读
          - 本地写迁移到独占修改，使其他核缓存行失效
          - 其他核写需迁移到失效
        - 失效
          - 本地缓存行失效
          - 本地不能读/写缓存行
          - 本地读需迁移到共享，其他核需迁移到共享
          - 本地写需迁移到独占修改，其他核该行失效
      - 通知其他核
        ```bash
                    全局缓存：记录缓存行拥有者信息
                      | dirty cpu1 cpu2 cpu3 |
                      |0     1    1    1     |

        | 状态 内容 |     | 状态 内容 |     | 状态 内容 |
            cpu1              cpu2             cpu3
        ```
      - 

pthread_yield：让出cpu
进程优先级：动态优先级，静态优先级

# 2 进程通信
## 2.1 分类


## 2.1 代码
### 一 信号 
```c
// 发送
kill(pid_t pid, int signum)
// 接收
signal(int signum, sig_handle_func()) /* 不阻塞，先恢复信号，再处理 */
sigaction(int signum, ...) /* 阻塞，先处理，再恢复信号 */
```
### 二 信号量 （Posix）
```c
#include <semaphore.h>
// 初始化
int sem_init(sem_t *sem, int pshared, unsigned int value); /* 0：进程内线程同步 */
int sem_destroy(sem_t *sem);
// 上锁
int sem_wait(sem_t *sem);
// 解锁
int sem_post(sem_t *sem);
// 创建 （有名信号量）
sem_t *sem_open(const char *name, int flag);
int sem_close(sem_t *sem);
int sem_unlink(const char *name);
// 其他
int sem_trywait(sem_t *sem);
int sem_timewait(sem_t *sem);
```
### 三 消息队列
```c
// 创建
int msgget(key_t key, int msgflg); /* flag: 访问权限 */
key_t ftok(const char *pathname int projid);
// 发送
int msgsnd(int msqid, const void *data, size_t datasz, int msgflag);
// 接收
ssize_t msgrcv(int msqid, void *data, size_t datasz, long msgtype, int msgflag); /* msgtype: 接收指定类型消息 */
// 删除、赋值、查询
msgctl(int msqid, int cmd, struct msqid_ds *buf);
```
### 四 管道
```c
// 创建（匿名管道）
int pipe(inf fd[2]); /* 0读1写 */
// 关闭
void close(int fd);
// 发送
int write(int fd, void *data, size_t datasz);
// 接收
int read(int fd, void *data, size_t datasz); /* 阻塞 */
// 创建 （命名管道: 对应真实文件） + open()
int mkfifo(const char *file, mode_t mode);
int mknode(const char *path, mode_t mode, dev_t device_type); /* 较老 */
```
### 五 共享内存
```c

```

### 六 套接字

## 2.3 命令
```bash
# 信号: 查看
kill -l

# 命名管道
mkfifo FILE
mkfifo FILE p
```
