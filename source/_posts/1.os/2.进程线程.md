

# 1 进程
## 1.1 概述
进程 Process/Task/Job 定义：某个数据集合上一次运行活动。资源分配单位。

进程控制块 Process Control Block PCB：进程描述符，进程属性

PCB 内容：
- 基本信息：pid, 进程名，userid
- CPU现场：寄存器，程序计数器，状态字PSW，栈指针，页表指针
- 控制信息：状态，优先级，代码执行入口，程序磁盘地址，运行统计信息（执行时间，页面调度），进程同步与通信，进程队列指针，进程消息队列指针
- 资源信息：虚拟地址空间，打开的文件

## 1.2 进程状态

进程状态及状态转换：
- 就绪态：CPU不空闲
  - -> 运行：被调度程序选中
- 运行态：
  - -> 就绪：时间片用完，高优先级抢占
  - -> 等待：系统调用、IO、进程通信、...
- 等待态：阻塞
  - -> 就绪：等待事件发生

其他状态：
- 创建态：
- 终止态：进程结束，统计运行信息，资源回收
- 挂起态：调节负载）（进程映像交换到磁盘）

linux 进程状态：
```c
fork()  ->  就绪态  ->  运行态  +-->  浅度睡眠 --+
                              |               |
                              +-->  深度睡眠 --+
                              |               |--> 就绪态 （wake_up / 信号）
                              +--> 暂停     --+
                              |              |
                              +--> 僵尸     --+
就绪->运行：schedule()
运行->就绪：时间片结束
运行->浅度睡眠：等待资源，interruptible_sleep_on()，schedule()
运行->深度睡眠：等待资源，sleep_on()，schedule()
运行->暂停：ptrace调试，schedule()
```

## 1.3 进程队列
进程状态改变：从一个队列出队，进入另一个队列
等待队列：等待事件不同，有多个等待队列

## 1.4 进程控制
- 创建 fork/exec：分配pid，分配pcb，复制父进程地址空间（linux优化：当子进程要写父进程地址时，才复制地址空间），继承父进程共享资源(打开的文件，工作目录)，设置队列指针
- 阻塞 wait 等待子进程：自己执行阻塞原语
- 唤醒
- 挂起
- 激活
- 撤销 exit：关闭文件，回收内存，撤销pcb

进程地址空间
```c
用户地址空间：
---------
 栈
 .
 .
 .
 堆
---------
数据段
---------
代码段
---------

操作系统地址空间：
```

上下文切换：将cpu硬件状态从一个进程换到另一个进程

线程优势：
- 开销小：创建和销毁，切换，通信
- 性能高：多处理器并发执行

线程控制：
- 线程id，线程状态，线程上下文，线程栈和栈指针

pthread_yield：让出cpu

## 1.5 cpu调度调度
场景：
n个线程，m个cpu，cpu现在线程运行

cpu调度时机：

进程上下文开销：
直接开销：保护和恢复寄存器、切换地址空间
间接开销：高速缓存失效、缓冲区缓存失效、TLB失效

调度算法衡量指标：
- 吞吐量
- 周转时间：请求 -> 运行
- 响应时间：请求 -> 第一次回应

- CPU利用率
- 等待时间：就绪 -> 运行

进程优先级：动态优先级，静态优先级

4.2




# 2 进程通信
## 2.1 分类
- 信号
- 信号量 （锁）
-  消息队列 （传递数据 + 阻塞）
- 管道 （传递数据 + 阻塞）
- 共享内存 （传递数据 + 阻塞）
- 套接字 （传递数据 + 阻塞）
## 2.1 代码
### 一 信号 
```c
// 发送
kill(pid_t pid, int signum)
// 接收
signal(int signum, sig_handle_func()) /* 不阻塞，先恢复信号，再处理 */
sigaction(int signum, ...) /* 阻塞，先处理，再恢复信号 */
```
### 二 信号量 （Posix）
```c
#include <semaphore.h>
// 初始化
int sem_init(sem_t *sem, int pshared, unsigned int value); /* 0：进程内线程同步 */
int sem_destroy(sem_t *sem);
// 上锁
int sem_wait(sem_t *sem);
// 解锁
int sem_post(sem_t *sem);
// 创建 （有名信号量）
sem_t *sem_open(const char *name, int flag);
int sem_close(sem_t *sem);
int sem_unlink(const char *name);
// 其他
int sem_trywait(sem_t *sem);
int sem_timewait(sem_t *sem);
```
### 三 消息队列
```c
// 创建
int msgget(key_t key, int msgflg); /* flag: 访问权限 */
key_t ftok(const char *pathname int projid);
// 发送
int msgsnd(int msqid, const void *data, size_t datasz, int msgflag);
// 接收
ssize_t msgrcv(int msqid, void *data, size_t datasz, long msgtype, int msgflag); /* msgtype: 接收指定类型消息 */
// 删除、赋值、查询
msgctl(int msqid, int cmd, struct msqid_ds *buf);
```
### 四 管道
```c
// 创建（匿名管道）
int pipe(inf fd[2]); /* 0读1写 */
// 关闭
void close(int fd);
// 发送
int write(int fd, void *data, size_t datasz);
// 接收
int read(int fd, void *data, size_t datasz); /* 阻塞 */
// 创建 （命名管道: 对应真实文件） + open()
int mkfifo(const char *file, mode_t mode);
int mknode(const char *path, mode_t mode, dev_t device_type); /* 较老 */
```
### 五 共享内存
```c

```

### 六 套接字

## 2.3 命令
```bash
# 信号: 查看
kill -l

# 命名管道
mkfifo FILE
mkfifo FILE p
```

# 3 