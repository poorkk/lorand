
pg-internal.vonng.com

# 1 进程
## 1.1 进程架构
进程架构：
- postmaster
- postgres
- wal writer
- background writer
- checkpointer
- autovacuum
- statistics collector：收集统计信息
- archiver：日志归档
- logging collertor：日志

## 1.2 进程启动时机
```c
#define StartupDataBase()		StartChildProcess(StartupProcess)
#define StartBackgroundWriter() StartChildProcess(BgWriterProcess)
#define StartCheckpointer()		StartChildProcess(CheckpointerProcess)
#define StartWalWriter()		StartChildProcess(WalWriterProcess)
#define StartWalReceiver()		StartChildProcess(WalReceiverProcess)

main()
    PostmasterMain()
        pqsignal(SIGUSR1, sigusr1_handler); // 注册wal接受进程信号量
        SysLogger_Start()
        StartupDataBase() -> StartupProcessMain() // 启动进程：故障恢复
        ServerLoop()
            BackendStartup()
            SysLogger_Start()
            StartCheckpointer() -> CheckpointerMain() // 检查点进程
            StartBackgroundWriter() -> BackgroundWriterMain() // 数据写进程
            StartWalWriter() -> InitXLOGAccess() WalWriterMain() // wal写进程
            StartAutoVacLauncher() // 清理进程
            pgstat_start() // 状态检查进程
            pgarch_start() // 归档进程
            maybe_start_bgworker()

WaitForWALToBecomeAvailable()
    RequestXLogStreaming()
        SendPostmasterSignal(PMSIGNAL_START_WALRECEIVER)
sigusr1_handler(PMSIGNAL_START_WALRECEIVER)
    StartWalReceiver()

StartChildProcess()
    AuxiliaryProcessMain()
        WalWriterMain()
        ...
```

## 1.3 进程功能
### 1 启动进程
1. 从control中，找到checkpoint位置，开始重放xlog
```c
StartupProcessMain()
    StartupXLOG()
        ReadControlFile()
            read(ControlFile)
        readRecoveryCommandFile() // 读取恢复控制文件recovery.conf
        if {

        } else {// 根据control中的checkpoint开始恢复
            ReadCheckpointRecord(ControlFile->checkPoint)
            RelationCacheInitFileRemove()
                unlink_initfile("pg_internal.init")
            
            MultiXactSetNextMXact()
            SetTransactionIdLimit()
            SetMultiXactIdLimit()
            SetCommitTsLimit()
            
            StartupReplicationSlots()
            StartupReorderBuffer()
            StartupMultiXact()
            StartupCommitTs()
            StartupReplicationOrigin()

            InRecovery = true
        }

        UpdateControlFile()
        pgstat_reset_all()
        CheckRequiredParameterValues()
        ResetUnloggedRelations()
        DeleteAllExportedSnapshotFiles()

        ProcArrayInitRecovery()
        StartupCLOG()
        StartupSUBTRANS()

        for (rmid <= RM_MAX_ID): // 启动资源管理器
            RmgrTable[rmid].rm_startup()
        
        PublishStartupProcessInformation()
        SendPostmasterSignal(PMSIGNAL_RECOVERY_STARTED)
        
        CheckRecoveryConsistency()
        record = ReadRecord(checkPoint.redo) // 从检查点找到第一条xlog记录
        do {
            /* 资源管理器redo xlog记录 */
            RmgrTable[record->xl_rmid].rm_redo(xlogreader)
            record = ReadRecord(InvalidXLogRecPtr)
        } while (record != NULL)

        for ():
            RmgrTable[rmid].rm_cleanup();

        ShutdownWalRcv()

        ...

        TrimCLOG()
        TrimMultiXact()
        LocalSetXLogInsertAllowed()
        XLogReportParameters()
        CompleteCommitTsInitialization()
        WalSndWakeup()
```

```c
typedef struct {
    ...
    DBState state;
    pg_time_t time; // 上次更新control文件的时间
    XLogRecPtr checkPoint; // 上次更新时的checkpoint点
    XLogRecPtr prevCheckPoint;

	XLogRecPtr	minRecoveryPoint;
	TimeLineID	minRecoveryPointTLI;
	XLogRecPtr	backupStartPoint;
	XLogRecPtr	backupEndPoint;
    ...
} ControlFileData;
```

### 2 wal写进程
```c
InitXLOGAccess()
    GetRedoRecPtr()
        RedoRecPtr = XLogCtl->RedoRecPtr
    InitXLogInsert() // 初始化内存
WalWriterMain()
    for (;;)
        XLogBackgroundFlush()
            LWLockAcquire(WALWriteLock)
            XLogWrite()
                curridx = XLogRecPtrToBufIdx(LogwrtResult.Write) // 找到上一次xlog点
                while (LogwrtResult.Write < WriteRqst.Write) // 计算长度，计算完成后才开始写入
                    XLogRecPtr EndPtr = XLogCtl->xlblocks[curridx];
                    LogwrtResult.Write = EndPtr; // 实时更新落盘位置
                    startidx = curridx;
                    npage++;
                    from = XLogCtl->pages + startidx * (Size) XLOG_BLCKSZ; // 计算落盘长度，BLKCZ可配置，1k到6m
                    if WriteRqst.Write <= LogwrtResult.Write:
                        write(from, npages * (Size) XLOG_BLCKSZ)
                        WalSndWakeupRequest()
                        XLogArchiveNotifySeg()
                        if (XLogCheckpointNeeded):
                            RequestCheckpoint(CHECKPOINT_CAUSE_XLOG)
                curridx = NextBufIdx(curridx)
            WalSndWakeupProcessRequests()
                WalSndWakeup()
            AdvanceXLInsertBuffer() // 扩张wal
        WaitLatch(WalWriterDelay)
            WaitLatchOrSocket()
                select() /* sleep */
```

# 2 机制
## 2.1 故障恢复
```c
// 全部资源管理器
RmgrData RmgrTable[#include "access/rmgrlist.h"] // 9.5共20种

// 资源管理器功能
typedef RmgrData {
	const char *rm_name;
	void (*rm_redo) (XLogReaderState *record);
	void (*rm_desc) (StringInfo buf, XLogReaderState *record);
	const char *(*rm_identify) (uint8 info);
	void (*rm_startup) (void);
	void (*rm_cleanup) (void);
} RmgrData;

// 资源管理器类型
RM_XLOG_ID xlog_redo
RM_XACT_ID xact_redo
RM_SMGR_ID smgr_redo // CREATE/TRUNCATE TABLE
RM_CLOG_ID clog_redo

RM_DBASE_ID dbase_redo
RM_TBLSPC_ID tblspc_redo
RM_MULTIXACT_ID multixact_redo

RM_HEAP2_ID heap2_redo // REWRITE/VACUUM/FREEZE_PAGE/VISIBLE/MULTI_INSERT/LOCK_UPDATE/NEW_CID
RM_HEAP_ID heap_redo // INSERT/DELETE/UPDATE/TRUNCATE/HOT_UPDATE/CONFIRM/LOCK/INPLACE/INIT_PAGE

RM_BTREE_ID btree_redo
RM_HASH_ID hash_redo
RM_GIN_ID gin_redo
RM_GIST_ID gist_redo
RM_SEQ_ID seq_redo
...

// xlog插入方法
XLogBeginInsert()
XLogRegisterData(data, datasz)
XLogRecPtr XLogInsert(RmgrId rmid, uint8 info)
XLogFlush(XLogRecPtr record)

// xlog插入时机 XLogInsert(RM_HEAP_ID
|- heap_insert()
|- heap_delete()
|- heap_update()
|- heap_lock_tuple()
|- heap_finish_speculative()
|- heap_abort_speculative()
|- heap_inplace_update()
|- log_heap_update()
    XLogInsert(RM_HEAP_ID)
...

// xlog重放时机
PostmasterMain()
    StartupProcessMain()
        StartupXLOG()

// xlog重放操作
heap_redo()
    switch(info):
        XLOG_HEAP_INSERT:
            heap_xlog_insert()
                if XLOG_HEAP_INIT_PAGE:
                    XLogInitBufferForRedo()
                    PageInit()
                else:
                    XLogReadBufferForRedo()
                        XLogReadBufferForRedoExtended() // 从磁盘读page
                            XLogReadBufferExtended()
                        MarkBufferDirty()
        XLOG_HEAP_DELETE()
            heap_xlog_delete()
        ...
```

## 2.2 checkpoint
```c
// checkpoint时机
#define CHECKPOINT_IS_SHUTDOWN	0x0001	/* Checkpoint is for shutdown */
#define CHECKPOINT_END_OF_RECOVERY	0x0002 /* end of wal end recovery */
#define CHECKPOINT_IMMEDIATE	0x0004	/* Do it without delays */
#define CHECKPOINT_FORCE		0x0008	/* Force even if no activity */
#define CHECKPOINT_FLUSH_ALL	0x0010	/* Flush all pages, including those belonging to unlogged tables */
/* These are important to RequestCheckpoint */
#define CHECKPOINT_WAIT			0x0020	/* Wait for completion */
/* These indicate the cause of a checkpoint request */
#define CHECKPOINT_CAUSE_XLOG	0x0040	/* XLOG consumption */
#define CHECKPOINT_CAUSE_TIME	0x0080	/* Elapsed time */

// checkpont实现
CheckpointerMain()
    for (;;) {
        ResetLatch()
        GetInsertRecPtr()
        CreateCheckPoint()
            InitXLogInsert()
            smgrpreckpt()
            GetOldestActiveTransactionId()
            WALInsertLockAcquireExclusive()
            WALInsertLockRelease()
            MultiXactGetCheckptMulti()

            // 先落盘
            CheckPointGuts()
                CheckPointCLOG()
                CheckPointCommitTs()
                CheckPointSUBTRANS()
                CheckPointMultiXact()
                CheckPointPredicate()
                CheckPointRelationMap()
                CheckPointReplicationSlots()
                CheckPointSnapBuild()
                CheckPointLogicalRewriteHeap()
                CheckPointBuffers()
                    BufferSync()
                    smgrsync()
                CheckPointReplicationOrigin()
                CheckPointTwoPhase()

            // 再写xlog记录
            XLogBeginInsert()
            XLogRegisterData()
            XLogInsert(RM_XLOG_ID)
            XLogFlush()
            // 最后更新控制文件
            UpdateControlFile()
            smgrpostckpt()

        smgrcloseall()

        CheckArchiveTimeout()
        pgstat_send_bgwriter()
        WaitLatch()
    }

// BufferSync
```

# 3 模块
## 3.1 恢复

## 3.2 checkpoint
```c

```


## 3.1 磁盘介质管理
接口
```c
void smgrcreate(SMgrRelation reln, ForkNumber forknum, bool isRedo); // 创建文件
void smgrdounlink(SMgrRelation reln, bool isRedo);

SMgrRelation smgropen(RelFileNode rnode, BackendId backend);
void smgrclose(SMgrRelation reln);

void smgrwrite(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum, char *buffer, bool skipFsync);
void smgrread(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum, char *buffer);
void smgrextend(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum, char *buffer, bool skipFsync);
```
调用关系
```c
// 索引模块
btbuildempty()
    smgrwrite(metapage)
_bt_blwritepage()
    smgrwrite()
spgbuildempty()
    smgrwrite()

|- FlushBuffer() ...
|- FlushRelationBuffers()
|- LocalBufferAlloc()
    smgrwrite()
```
```c
// FlushBuffer
|- BufferAlloc() // readBuffer时，申请一个buffer，可能调用页面淘汰算法
|- FlushDatabaseBuffers()
|- FlushRelationBuffers()
|- FlushOneBuffer()
    FlushBuffer()

// FlushOneBuffer
XLogReadBufferForRedoExtended()
    FlushOneBuffer()

// FlushRelationBuffers
|- heap_sync()
|- ATExecSetTableSpace() // ALTER TABLE SET TABLESPACE
    FlushRelationBuffers()
// heap_sync when HEAP_INSERT_SKIP_WAL
|- intorel_shutdown() 
|- CopyFrom()
|- transientrel_shutdown()
|- ATRewriteTable()
    heap_sync()

// FlushDatabaseBuffers
dbase_redo()
    FlushDatabaseBuffers()
```
write时机：
1. readBuffer时，如果buffer不在内存，且共享缓冲池已满，调用页面置换算法进行刷盘
2. alter table set table space
3. copy

### xlog接口
```c
/* 插入 */
XLogRecPtr XLogInsertRecord(struct XLogRecData *rdata, XLogRecPtr fpw_lsn)
/* 落盘 */
XLogFlush(XLogRecPtr RecPtr)
xlog_redo(XLogReaderState *record)

XLogRecPtr GetXLogReplayRecPtr()
XLogRecPtr GetXLogInsertRecPtr()
XLogRecPtr GetXLogWriteRecPtr()

UpdateControlFile()

StartupXLOG()
ShutdownXLOG()
WakeupRecovery()
```
